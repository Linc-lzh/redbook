zset ids 所有一级评论的ids   所有二级评论的ids
10条一级评论 10条二级评论
一个一级评论的ids 10个二级评论的ids

评论的具体的内容和一些索引 字符串当中

mget（批量获取Redis当中的数据） mset（批量去写入Redis数据）
先去展示了所有的一级评论 - 先查询所有的一级评论 - 先查询一级评论的zset - 根据一级评论的zset然后通过mget查询所有的具体的索引和内容，然后返回
mget不能同一个请求获取太多的内容，否则性能会非常低

优化：
先查询所有的一级评论的zset（1w条数据）然后返回给前端
根据zset的排序方式获取最上面的20条请求到后端进行这么一个展示 - 通过ids（20条）使用mget进行获取
当用户滑动的时候，我们进行一个预加载，滑动的时候直接去请求下一页

举个例子：如果说我们把评论点赞数量也放入到评论内容的redis字符串当中，他有什么问题？
如果给这个评论点赞，就需要存redis当中拿到数据，序列化，拿到点赞的属性+1，然后再反序列化之后set回去redis当中
这一个操作是需要5步来完成的，数据可能是不一致的
100 100+1 100+1 101 set回去 101 正确数据应该是102 这里有个问题就是评论系统，我们评论的数据太多了，存储到redis当中的数据都有很多啊

我们就需要单独存储点赞的数
有一个hash来去存储我们的点赞数
hash【key：objId+parent】【hkey：commentId】【value：点赞数】
hash和字符串，value是整数字符的时候，我们可以直接进行+1或者-1的操作
不是：先查询点赞数，+1操作，set回去

评论点赞：
比如说我每一条评论都有一个对应的list 包含了所有点赞用户的userId
如果说匹配上的话，就说明我这里是点赞的，如果都没有匹配上的话，说明就是没有点赞的

mget 20条 假设每条评论的点赞数是10 list userIds是10条
20*10 200次
如果说我有热门视频的话。评论区可能也是一个热门评论区
10w次点赞 1k点赞 1k*19
有好几条都是上万点赞，并且有部分是10w+点赞
100w
for 20次吧所有的list查询出来
for 20个list
for list里面具体的点赞的userIds 跟我们的userId进行匹配
在我们互联网项目当中，如果说我们要求是必须在多少ms之内响应，那这速度显然是差点意思
大key的问题 大key问题 拆分大key

那这里我们就可以去使用我们的布隆过滤器

我们使用布隆过滤器 每一个评论对应一个布隆过滤器 查询评论的时候，我们先查询出来20条评论对应的20个布隆过滤器
60次的hash运算来判断用户是否给这20条评论点赞过
有一定的误判率：分为两种情况，一种是点赞过，一种是没点赞过，但是误判了
但是，如果说你不在布隆过滤器当中，那就是一定没点赞过的
判断，如果说不存在，就一定是没点赞过的，通常情况下都是没点赞过的
我们就可以允许误判，查询数据库，或者查询redis当中的点赞列表等等

如果用户他点赞之后取消了怎办？但是如果说他点赞的评论很多的话，可能会出现一个问题，就是重新构建布隆过滤器的时间是比较长的
其实我们有一个取消点赞的list 就ok了
如果说存在的话，就有三种情况，第一种就是真的点赞了，第二种就是没点赞过，误判了，第三种了就是点赞了之后取消了
针对于评论是否点赞这一块的操作

就是我们不以评论为维度进行创建布隆过滤器和取消点赞list
每天可能都有10w条视频发布，每条视频1k条评论的话
我们以用户为维度进行创建布隆过滤器和取消点赞的list
100w的用户，活跃用户20-30% 1天创建的布隆过滤器和取消点赞的list 20w-30w的数据
存储用户所有点赞的评论的commentId和取消点赞list commentIds

